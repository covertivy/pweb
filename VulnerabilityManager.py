#!/usr/bin/python3
import PluginManager
import OutputManager
import os
from Classes import Data
import threading
from colors import COLOR_MANAGER

MAX_THREADS = 4


def get_plugin_funcs():
    """
    This function gets the list of plugin `check` functions from the check device.
    @returns None.
    """
    # Check if the `CheckDevice` file actually exists.
    if os.path.exists(os.getcwd() + f"/{PluginManager.CHECK_DEVICE_NAME}.py"):
        try:
            import CheckDevice  # Try to import `CheckDevice` (if name was changed make sure to change here!).

            # Get the list of plugin `check` functions from the CheckDevice and return it.
            return CheckDevice.ALL_FUNCS
        except ModuleNotFoundError as e:  # Error in Check Device plugin imports.
            raise Exception(
                f"Could not import {PluginManager.CHECK_DEVICE_NAME}.py as a python module!\n\t( {e} )\nAborting...",
                "\t",
            )
        # Catch any other error (could be function 'check' does not exist in a plugin module).
        except Exception as error:
            raise Exception(f"{error} \n\tAborting...", "\t")
    else:  # The `CheckDevice` file does not exist.
        raise Exception(
            f"Check device does not exist!\n\t({PluginManager.CHECK_DEVICE_NAME}.py)\nAborting...",
            "\t",
        )


def logic(data: Data):
    """
    This function runs the plugins on separted threads and activates the `OutputManager`.
    @param data (Classes.Data): The data object of the program.
    @returns None.
    """
    plugins: list = get_plugin_funcs()  # A list of all the plugin `check` functions.
    threads: list = list()
    for plugin in plugins:
        threads.append(threading.Thread(target=plugin, args=(data,)))
    all_threads_done_event: threading.Event = threading.Event()
    output = threading.Thread(
        target=OutputManager.logic, args=(data, all_threads_done_event)
    )

    print(
        f"{COLOR_MANAGER.PURPLE + COLOR_MANAGER.HEADER}Running plugins:{COLOR_MANAGER.ENDC}"
    )
    output.setDaemon(True)
    output.start()  # Run the OutputManager as a daemon thread.
    index = 0  # Current index in the threads list.
    while True:
        alive = 0
        for thread in threads:
            if thread.is_alive():
                alive += 1
        # Check if we can run any new threads.
        if alive < MAX_THREADS and index < len(threads):
            # Add a thread to the list of running threads.
            threads[index].setDaemon(True)
            threads[index].start()
            index += 1
        elif alive == 0:
            # All the threads finished their run.
            break
    # Notify the `OutputManager` that the threads finished their run.
    all_threads_done_event.set()
    output.join()  # Waiting for the `OutputManager` to finish it's run.
