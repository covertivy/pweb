#!/usr/bin/python3
import PluginManager
import OutputManager
import os
import Data
import threading

MAX_THREADS = 4


def get_plugin_funcs():
    if os.path.exists(
        os.getcwd() + f"/{PluginManager.CHECK_DEVICE_NAME}.py"
    ):  # Check if it actually exists.
        try:
            from CheckDevice import ALL_FUNCS  # Try to import.
        except ModuleNotFoundError as e:  # Error in Check Device plugin imports.
            raise Exception(
                f"Plugin files missing from the specified plugin folder!\n\t( {e} )\nAborting..."
            )
        # Catch any other error (could be function 'check' does not exist in a plugin module)
        except Exception as error:
            raise Exception(f"{error} \n\tAborting...")
        finally:
            return ALL_FUNCS  # Get and return the list of all plugin functions from Check Device.
    else:  # Check file does not exist.
        raise Exception(
            f"Check device does not exist!\n\t({PluginManager.CHECK_DEVICE_NAME}.py)\nAborting..."
        )


def logic(data: Data.Data):
    mutex = threading.Lock()  # Whenever a plugin is using data object
    plugins = get_plugin_funcs()  # List of the functions of the plugins
    threads = list()
    for plugin in plugins:
        threads.append(threading.Thread(target=plugin, args=(data, mutex)))

    all_threads_done_event = threading.Event()
    output = threading.Thread(
        target=OutputManager.logic, args=(data, mutex, all_threads_done_event)
    )
    output.start()  # Output manager waits for results.
    index = 0  # Current index in the threads list.
    while True:
        alive = 0
        for thread in threads:
            if thread.is_alive():
                alive += 1
        if alive < MAX_THREADS and index < len(threads):
            # If we can add more threads to the process and there are more threads to add.
            threads[index].start()
            index += 1
        elif alive == 0:
            # All the threads finished their run.
            break
    # Signalling the output manager that the threads finished their run.
    all_threads_done_event.set()
    output.join()  # Waiting for the Output manager to finish it's run.
